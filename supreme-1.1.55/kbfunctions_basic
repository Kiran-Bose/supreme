#!/bin/bash
#kiran.vkvr@gmail.com
#https://github.com/Kiran-Bose/supreme

#------------------------------------------------------------------------------------------------
function numval ()
{
re='^[0-9, ]+$'
if ! [[ $1 =~ $re ]] ; then
   echo "f"
else
   echo "p"
fi
}

#------------------------------------------------------------------------------------------------
function srch ()
{
arraysrch=( )
arraystep=( )
srcharr=( "$@" )
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
for srchemt in "${srcharr[@]}"
do
	case "$optdir1" in
	D)IFS=$'\n' read -rd '' -a arraystep <<< `sudo find /mnt /home/"$user"/Downloads /home/"$user"/Videos /media/"$user" -iname  "*$srchemt*"`
	  arraysrch+=( "${arraystep[@]}" );;
	NOUSB)IFS=$'\n' read -rd '' -a arraystep <<< `sudo find /mnt /home/"$user"/Downloads /home/"$user"/Videos -iname  "*$srchemt*"`
	      arraysrch+=( "${arraystep[@]}" );;
	USBONLY)IFS=$'\n' read -rd '' -a arraystep <<< `sudo find /media/"$user" -iname  "*$srchemt*"`
		arraysrch+=( "${arraystep[@]}" );;
	UD)if [[ -z "$srch11" ]]
	   then
	   instfmt "Input Path"
	   read srch11
	   fi
	   IFS=$'\n' read -rd '' -a arraystep <<< `sudo find "$srch11" -iname  "*$srchemt*"`
	   arraysrch+=( "${arraystep[@]}" );;
	*)return;;
	esac
done
arraysrch=( $(remove_array_dups "${arraysrch[@]}") )
colorfmt "${arraysrch[@]}"
unset srch11
IFS=$SAVEIFS
if [ "${#arraysrch[@]}" == 0 ]
then
flag=0
echo -e "\e[91mNo match found\e[0m"
return
else
flag=1
fi
}

#------------------------------------------------------------------------------------------------
function slct ()
{
slctarr=( "$@" )
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
OUTPUT=""
case "$navdoor" in
DOOR)for srchemt1 in "${slctarr[@]}"
     do
     OUTPUT="${arraysrch[$srchemt1]}"";""$OUTPUT"
     done;;
NAV)for srchemt1 in "${slctarr[@]}"
    do
    OUTPUT="${temppath[$srchemt1]}"";""$OUTPUT"
    done;;
GDNAV)for srchemt1 in "${slctarr[@]}"
      do
      OUTPUT="${newitem[$srchemt1]}"";""$OUTPUT"
      done;;
esac
echo "$OUTPUT"
}

#------------------------------------------------------------------------------------------------
function door ()
{
flag=0
navdoor="DOOR"
arraymock=( )
optdir1="${1:-D}"
instfmt "enter wildcard(s)"
read mockwc
IFS=', ' read -a mockopt <<< "$mockwc"
fso="y"
rpt="y"
while [ "$rpt" == "y" ]
do
if [ "$fso" == "y" ]
then
qksrch "${mockopt[@]}"
	if [ $flag == 0 ]
	then
	echo -e "\e[91mquick search couldn't locate anything. Executing normal search. Please wait...\e[0m"
	srch "${mockopt[@]}"
	fi
else
srch "${mockopt[@]}"
fi
if [ $flag == 1 ]
then
instfmt "Select file(s) | Enter 'a' to select all | 'z' for inverse selection | 's' for slow search(if file not found/file not opening) | 'h' to go home"
read srch1
	case "$srch1" in
	a|A)rpt="n"
	  srchopt=()
	  for ((i=0; i<${#arraysrch[@]}; i++)); do
	  srchopt+=( "$i" )
	  done
	  actionitems;;
	z|Z)rpt="n"
	  invslct "${arraysrch[@]}";;
	h|H)rpt="n"
	  supreme;;
	s|S)fso="n";;
	*)rpt="n"
	  v11=$( echo $(numval "$srch1") )
	  IFS=', ' read -r -a srchopt <<< "$srch1"
		if [ "$v11" == "p" ]
		then
		actionitems
		else
		echo -e "\e[91mBad Input\e[0m"
		return
		fi;;
	esac
else
return
fi
done
}

#------------------------------------------------------------------------------------------------
function actionitems ()
{
slctin=$( echo "$(slct "${srchopt[@]}")" )
mockres=$(echo "${slctin[@]}" | tr ';' '\n' | sort -nr)
IFS=$'\n' read -rd '' -a arraymock <<< "$mockres"
colorfmt "${arraymock[@]}"
echo -e "\e[91mSelected ${#arraymock[@]} item(s)\e[0m"
}

#------------------------------------------------------------------------------------------------
function navig ()
{
dividerarray=()
arraymock=()
flag=1
navdoor="NAV"
navpath="${1:-/}"
check=$( echo "$navpath"/* | rev | cut -d '/' -f 1 | rev )
if [ "$check" == "*" ]
then
echo -e "\e[91mFolder empty\e[0m"
temppath=()
instfmt "Enter b to go back | 'm' to create new directory | 'f' to create new file | 'h' to go home"
else
temppath=("$navpath"/*)
for ((i=0; i<${#temppath[@]}; i++)); do
Q=$( echo "(${i}) ${temppath[$i]}" | rev | cut -d '/' -f 1 | rev )
dividerarray+=( "$Q" )	
done
colorfmt "${dividerarray[@]}"
instfmt "Select item(s) | Enter 'a' to select all | 'z' for inverse selection | 'n' for navigation | 'b' to go back | 'm' to create new directory | 'f' to create new file | 'h' to go home" 
fi
read navig1
v11=$( echo $(numval "$navig1") )
case "$navig1" in
n|N)instfmt "Select folder to navigate"
  read navig2
  v1000=$( echo $(numval "$navig2") )
	if [ "$v1000" == "p" ]
	then
	navig "${temppath[$navig2]}"
	else
	return
	fi;;
b|B)backpath="`echo "$navpath" | rev | cut -d/ -f2- | rev`"
  navig "$backpath";;
a|A)srchopt=()
    for ((i=0; i<${#temppath[@]}; i++)); do
    srchopt+=( "$i" )
    done
    actionitems;;
z|Z)invslct "${temppath[@]}";;
m|M)instfmt "Enter name for new directory"
    read navignd
	if [[ "$navpath" == *"/1000/gvfs/mtp"* ]]
	then
	mkdir "$navpath"/"$navignd"
	else
	sudo mkdir "$navpath"/"$navignd"
	fi
    navig "$navpath";;
f|F)instfmt "Enter file name"
    read navignf
	if [[ "$navpath" == *"/1000/gvfs/mtp"* ]]
	then
	touch "$navpath"/"$navignf"
	else
	sudo touch "$navpath"/"$navignf"
	fi
    navig "$navpath";;
h|H)supreme;;
*)if [ "$v11" == "p" ]
  then
  IFS=', ' read -r -a srchopt <<< "$navig1"
  actionitems
  else
  echo -e "\e[91mBad Input\e[0m"
  return
  fi;;
esac
}

#------------------------------------------------------------------------------------------------
function quick ()
{
quickarray=( )
exd="${1:-D}"
if [ "$exd" == "D" ]
then
quickarray=( "/home/$user" )
else
quickarray=( )
fi
usb=/media/$user/
usbquick=( "$usb"* )
device=/run/user/1000/gvfs/mtp
access=("$device"*)
path="$access"/
droidquick=( "$path"* )
checkdroid=$( echo "$path"* | cut -d '/' -f 7 )
checkusb=$( echo "$usb"* | cut -d '/' -f 4 )
if [[ ("$checkdroid" == "*") && ("$checkusb" == "*") ]]
then
echo -e "\e[91mNo external quick access folder available\e[0m"
elif [[ ("$checkdroid" != "*") && ("$checkusb" == "*") ]]
then
quickarray+=( "${droidquick[@]}" )
elif [[ ("$checkusb" != "*") && ("$checkdroid" == "*") ]]
then
quickarray+=( "${usbquick[@]}" )
elif [[ ("$checkdroid" != "*") &&  ("$checkusb" != "*") ]]
then 
quickarray+=( "${usbquick[@]}" "${droidquick[@]}" )
else
return
fi
if [ "${#quickarray[@]}" != 0 ]
then
colorfmt "${quickarray[@]}"
else
return
fi
}

#------------------------------------------------------------------------------------------------
function feeder ()
{
arraymock=( )
instfmt "Enter 's' for search | 'n' for navigation | 'q' for quick access | 'h' to go home"
read opn1
case "$opn1" in
s|S)echo -e "\e[93mSelect an option\n(1)Default\n(2)Path specific\e[0m"
   read opn4
   case "$opn4" in
   1)door;;
   2)door UD;;
   *)return;;
   esac;;
n|N)navig /;;
h|H)supreme;;
q|Q)quick
	if [ "${#quickarray[@]}" != 0 ]
	then
	instfmt "Select an option | Enter 'b' to go back | 'h' to go home"
	read opn15
	v101=$( echo $(numval "$opn15") )
		case "$opn15" in
		b|B)feeder;;
		h|H)supreme;;
		*)if [[ ("$v101" == "p") && ( $opn15 < $j ) ]]
		  then
		  navig "${quickarray[$opn15]}"
		  else
		  return
		  fi;;
		esac
	else
	return
	fi;;
*)return;;
esac
}

#------------------------------------------------------------------------------------------------
function invslct ()
{
if [[ $# -ne 0 ]]
then
invarr=( "$@" )
srchopt=()
srchopt1=()
	for ((i=0; i<${#invarr[@]}; i++)); do
	srchopt1+=( "$i" )
	done
instfmt "Select file(s) that need to be excluded | Enter 'h' to go home"
read srch27
v27=$( echo $(numval "$srch27") )
	case "$srch27" in
	h|H)supreme;;
	*)if [ "$v27" == "p" ]
	  then
	  IFS=', ' read -r -a invopt <<< "$srch27"
	  srchopt=( $(printf "%s\n" "${srchopt1[@]}" "${invopt[@]}" | sort | uniq -u) )
		if [ "$navdoor" == "GDNAV" ]
		then
		actionitems
		dfsort
		else
		actionitems
		fi
	  else
	  echo -e "\e[91mBad Input\e[0m"
	  return
	  fi;;
	esac
fi
}

#------------------------------------------------------------------------------------------------
function qksrch ()
{
arraysrch=( )
arraystep=( )
SAVEIFS=$IFS
case "$optdir1" in
D)IFS=$'\n' read -rd '' -a arraysrch <<< `sudo locate -i "$@" | egrep "/mnt|/home/$user/Downloads|/home/$user/Videos|/media/$user"`;;
NOUSB)IFS=$'\n' read -rd '' -a arraysrch <<< `sudo locate -i "$@" | egrep "/mnt|/home/$user/Downloads|/home/$user/Videos"`;;
USBONLY)IFS=$'\n' read -rd '' -a arraysrch <<< `sudo locate -i "$@" | egrep "/media/$user"`;;
UD)echo -e "\e[93mInput Path\e[0m"
   read srch11
   IFS=$'\n' read -rd '' -a arraysrch <<< `sudo locate -i "$@" | egrep "$srch11"`;;
*)return;;
esac
colorfmt "${arraysrch[@]}"
IFS=$SAVEIFS
if [ "${#arraysrch[@]}" == 0 ]
then
flag=0
echo -e "\e[91mNo match found\e[0m"
return
else
flag=1
fi
}

#------------------------------------------------------------------------------------------------
function remove_array_dups () 
{
# Usage: remove_array_dups "array"
declare -A tmp_array
for i in "$@"; do
[[ "$i" ]] && IFS=" " tmp_array["${i:- }"]=1
done
IFS=$'\n' read -rd '' -a rdarray <<< $( printf '%s\n' "${!tmp_array[@]}" )
for ((q=0; q<${#rdarray[@]}; q++)); do
echo "${rdarray["$q"]}"
done
}

#------------------------------------------------------------------------------------------------
function det ()
{ 
filename=$1;
fname=$( echo "$filename" | rev | cut -d '/' -f 1 | rev )
dname=$( echo "$filename" | rev | cut -d '/' -f 2- | rev )
fsys=$( df "$filename" | awk '{print $1}' | sed 1d )
idn=$( ls -i "$filename" | cut -d ' ' -f 1 )
if [[ (-d "$filename") && ("$filename" != "/") ]]
then
detfeed
spcon=$(sudo du -sh "$filename" | cut -c 1-4)
echo -e "\e[39;94;1mDisk Space Consumed\e[0m:$spcon"
elif [ "$filename" == "/" ]
then
detfeed
spcon=$(sudo df -ah "$filename" | awk '{print $3}' | sed 1d)
echo -e "\e[39;94;1mDisk Space Consumed\e[0m:$spcon"
else
detfeed
echo -e "\e[39;94;1mPermission Level\e[0m:$( ls -l "$filename" | cut -d ' ' -f 1 )\n\e[39;94;1mInode number\e[0m:$idn"
fi
}

#------------------------------------------------------------------------------------------------
function detfeed ()
{
if [ -z "$filename" ]
then
return
else
echo -e "\e[39;94;1mName\e[0m:"$fname"\n\e[39;94;1mDirectory\e[0m:"$dname"\n\e[39;94;1mOwner\e[0m:$(ls -dl "$filename" | cut -f3 -d' ')\n\e[39;94;1mDate Modified\e[0m:$(ls -dl "$filename" | awk '{print $6" "$7" "$8}')\n\e[39;94;1mType\e[0m:$(file "$filename" | cut -f2 -d: | cut -f1 -d,)\n\e[39;94;1mSize\e[0m:$(ls -hld "$filename" | cut -f5 -d' ')"
echo -e "\e[39;94;1mFileSystem On\e[0m:$fsys"
	if [ -d "$filename" ]
	then
	cd "$filename"
	nof=$( ls -afq | wc -l )
	echo -e "\e[39;94;1mChild count\e[0m:$(($nof-2))"
	cd
	fi
fi
}

#------------------------------------------------------------------------------------------------
function colorfmt ()
{
tput reset
banner
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
holdarray=()
fmtarray=( $@ )
for ((j=0; j<${#fmtarray[@]}; j++))
do
holdarray+=( "($j) ${fmtarray[$j]}" )
done
col=$(tput cols)
for ((n=0; n<${#holdarray[@]}; n++))
do
len=${#holdarray[$n]}
	if [[ "$col" -gt "$len" ]]
	then
	difr=$(($col-$len))
	else
	dif=$(($len-$col))
		while [[ "$dif" -gt "$col" ]]
		do
		dif=$(($dif-$col))
		done
	difr=$(($col-$dif))
	fi
	if (( $n % 2 == 0 ))
	then
	echo -en "\e[100;93;1;82m${holdarray[$n]}\e[0m"
		for ((i=0; i<$difr; i++))
		do
		echo -en "\e[100m \e[0m"
		done
	echo
	else
	echo -en "\e[103;90;1;82m${holdarray[$n]}\e[0m"
		for ((i=0; i<$difr; i++))
		do
		echo -en "\e[103m \e[0m"
		done
	echo
	fi
done
echo
IFS=$SAVEIFS
}

#------------------------------------------------------------------------------------------------
function instfmt ()
{
instset=()
instset=( "$*" )
col=$(tput cols)
len=${#instset[0]}
if [[ "$col" -gt "$len" ]]
then
difr=$(($col-$len))
else
dif=$(($len-$col))
	while [[ "$dif" -gt "$col" ]]
	do
	dif=$(($dif-$col))
	done
difr=$(($col-$dif))
fi
echo -en "\e[100;97;1;82m${instset[@]}\e[0m"
for ((i=0; i<$difr; i++))
do
echo -en "\e[100m \e[0m"
done
echo
}
#------------------------------------------------------------------------------------------------
function banner ()
{
user=$(whoami)
col=$(tput cols)
pos=$(($col/2-7))

for ((i=0; i<$col; i++))
do
echo -en "\e[100m \e[0m"
done
echo -en "\0015"
for ((i=0; i<$pos; i++))
do
echo -en "\e[100m \e[0m"
done
echo -en "\e[100;93;1;82mSupreme-1.1.55\e[0m"
echo
for ((i=0; i<$col; i++))
do
echo -en "\e[101m \e[0m"
done
echo -en "\0015"
echo -en "\e[101;97;1;82m$user\e[0m"
echo
}
#------------------------------------------------------------------------------------------------
function cloudnavig ()
{
arraymock=()
sortindex=()
sortfile=()
sortdir=()
isdir=()
if [[ (-z "$cldopt") && ($# -eq 0) ]]
then
return
else
navdoor="GDNAV"
newitem=()
gdn1="${1:-$cldopt}"
gditems=( "$(rclone lsjson "$gdn1")" )
	for row in $(echo "${gditems}" | jq -r '.[] | @base64'); do
	    _jq() {
	     echo ${row} | base64 --decode | jq -r ${1}
	    }

	    newitem+=( "$(_jq '.Path')" )
	    isdir+=( "$(_jq '.Size')" )

	done
colorfmt "${newitem[@]}"
instfmt "Select item(s) | Enter 'a' to select all | 'z' for inverse selection | Enter 'n' for navigation | 'b' to go back | 'v' to view file | 'f' to view folder structure and navigate | 'm' to make new directory | 'h' to go home" 
read gdn2
v122=$( echo $(numval "$gdn2") )
	case "$gdn2" in
	n|N)gdopn="y"
	    instfmt "Select folder to navigate | Enter 'b' to go back | 'h' to go home"
	    while [ "$gdopn" == "y" ]
	    do
	    read gdn3
	    v1010=$( echo $(numval "$gdn3") )
		  case "$gdn3" in
		  b|B)gdopn="f"
		      backpath="`echo "$gdn1" | rev | cut -d/ -f2- | rev`"
		      cloudnavig "$backpath";;
		  h|H)gdopn="f"
		      unset cldopt
		      supreme;;
		  *)if [[ ("$v1010" == "p") && ("${isdir[$gdn3]}" == -1) ]]
		    then
		    gdopn="f"
			if [ "$gdn1" == "$cldopt" ]
			then
			cloudnavig "$gdn1""${newitem[$gdn3]}"
			else
			cloudnavig "$gdn1"/"${newitem[$gdn3]}"
			fi
		   else
		   echo -e "\e[91mNot a directory/Bad Input\e[0m"
		   fi;;
		   esac
	    done;;
	h|H)unset cldopt
	    supreme;;
	v|V)instfmt "Select file(s) to view"
	    read gdn11
	    v120=$( echo $(numval "$gdn11") )
		if [ "$v120" == "p" ]
		then
		IFS=', ' read -r -a srchopt <<< "$gdn11"
		actionitems
			for gdnavemt in "${arraymock[@]}"
			do
			rclone copy "$gdn1"/"$gdnavemt" "/home/$user/Supremetemp"
			done
			for gdnavemt in "${arraymock[@]}"
			do
			xdg-open /home/"$user"/Supremetemp/"$gdnavemt"
			done
		instfmt "Do you want to perform actions on the selected file(s)?(y/n)"
		read gdn22
			if [ "$gdn22" == "y" ]
			then
			sudo rm -rf /home/"$user"/Supremetemp/*
			return
			else
			sudo rm -rf /home/"$user"/Supremetemp/*
			cloudnavig
			fi
		fi;;
	b|B)backpath="`echo "$gdn1" | rev | cut -d/ -f2- | rev`"
	    cloudnavig "$backpath";;
	f|F)rclone tree $gdn1 -d --full-path
	    instfmt "Enter path"
	    read gdn18
	    cloudnavig $gdn1"$gdn18";;
	m|M)instfmt "Enter name for new directory"
	    read gdnnd
	    rclone mkdir $gdn1/"$gdnnd"
	    cloudnavig $gdn1;;
	z|Z)invslct "${newitem[@]}";;
	a|A)srchopt=()
	    for ((i=0; i<${#newitem[@]}; i++)); do
	    srchopt+=( "$i" )
	    done
	    actionitems
	    dfsort;;
	*)if [ "$v122" == "p" ]
	  then
	  IFS=', ' read -r -a srchopt <<< "$gdn2"
	  actionitems
	  dfsort
	  else
	  echo -e "\e[91mBad Input/root folder selected as destination\e[0m"
	  return
	  fi;;
	esac
fi
}

#------------------------------------------------------------------------------------------------
function dfsort ()
{
for sortemt in "${srchopt[@]}"
do
	if [ "${isdir[$sortemt]}" == -1 ]	
	then
	sortdir+=( "${newitem[$sortemt]}" )
	sortindex+=( "$sortemt" )
	fi
done
sortfileinp=( $(printf "%s\n" "${srchopt[@]}" "${sortindex[@]}" | sort | uniq -u) )
for sortemt1 in "${sortfileinp[@]}"
do
sortfile+=( "${newitem[$sortemt1]}" )
done		
}





